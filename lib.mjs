import { readFileSync } from 'fs';

export {
  read,
  overlaps,
  last,
  allButLast,
  fill,
  splitByN,
  setIndex,
  log,
  serialize,
  deserialize,
  memoize,
  sort,
  dict,
  set,
  repeat,
  iterate
};

function read(file) {
  return readFileSync(file, 'utf8').trimRight().split(/\n/).map(row => row.trimRight());
}

// Do two ordered ranges overlap?
function overlaps(p1, p2) {
  // Test both ways in case p2 encloses p1 etc.
  return half(p1, p2) || half(p2, p1);
  function half(p1, p2) {
    // Why is this extra set of parens important? I have no idea
    return (
      // p1 encloses p2 entirely
      ((p1[0] <= p2[0]) && (p1[1] >= p2[1])) ||
      // p1 encloses first point of p2
      ((p1[0] <= p2[0]) && (p1[1] >= p2[0])) ||
      // p1 encloses second point of p2
      ((p1[0] <= p2[1]) && (p1[1] >= p2[1]))
    );
  }
}

function last(a) {
  return a[a.length - 1];
}

function allButLast(a) {
  return a.slice(0, a.length - 1);
}

function fill(a, length, fill) {
  const result = [...a];
  for (let i = a.length; (i < length); i++) {
    result.push(fill());
  }
  return result;
}

// Return a new array in which a[i] is set to v and the other values are unchanged
function setIndex(a, i, v) {
  // Just as fast as slicing twice and easier to follow
  const a2 = [...a];
  a2[i] = v;
  return a2;
}

// Return an array generated by invoking `fn()` once for each of `n` elements
function repeat(n, fn) {
  const a = [];
  for (let i = 0; (i < n); i++) {
    a.push(fn());
  }
  return a;
}

// Returns an immutable dictionary (aka "Map") with `set` and `delete` methods that return
// new dictionaries. The `data` argument is intended as an implementation detail for
// `set` and `delete` to invoke

function dict(data = {}) {
  const self = {
    data,
    has(key) {
      return Object.hasOwn(self.data, key);
    },
    set(key, value) {
      return dict({ ...self.data, [key]: value });
    },
    delete(key) {
      const {
        [key]: discard,
        ...newData
      } = self.data;
      return dict(newData);
    },
    get(key) {
      return Object.hasOwn(self.data, key) ? self.data[key] : undefined;
    },
    keys() {
      return Object.keys(self.data);
    }
  };
  return self;
}

// Returns an immutable set with `add` and `delete` methods that return
// new dictionaries. The `data` argument is intended as an implementation detail for
// `add` and `delete` to invoke

function set(data = {}) {
  const self = {
    data,
    has(key) {
      return Object.hasOwn(self.data, key);
    },
    add(key) {
      return set({
        ...self.data,
        [key]: true
      });
    },
    delete(key) {
      const {
        [key]: discard,
        ...newData
      } = self.data;
      return set(newData);
    },
    keys() {
      return Object.keys(self.data);
    },
    size() {
      return self.keys().length;
    }
  };
  return self;
}


// Split a string s into substrings of length n

function splitByN(s, n) {
  const cols = [];
  for (let i = 0; (i < s.length); i += n) {
    cols.push(s.slice(i, i + n));
  }
  return cols;
}

function log(v) {
  console.log(JSON.stringify(v, null, '  '));
  return v;
}

function serialize(v) {
  return JSON.stringify(v);
}

function deserialize(v) {
  return JSON.parse(v);
}

// Sort that returns a new array without modifying the original
function sort(a, fn) {
  return [...a].sort(fn);
}

// Return an array containing the integers 0 through n-1

function iterate(n) {
  const a = [];
  for (let i = 0; (i < n); i++) {
    a.push(i);
  }
  return a;
}

// Return a version of the function that caches previous results
// for the same set of arguments
function memoize(fn) {
  let cache = dict();
  return (...args) => {
    const key = serialize(args);
    if (cache.has(key)) {
      return cache.get(key);
    }
    const value = fn(...args);
    cache = cache.set(key, value);
    return value;
  };
}

